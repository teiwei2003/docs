# 合约构成

给定发送消息的 [Actor 模型](./actor) 和 CosmWasm v0.8 中实现的 [同步查询](./query)，我们拥有所有原始组件
使合约与其他合约和本机模块的任意组合成为可能.在这里，我们将解释这些组件如何组合在一起以及如何扩展它们.

**注意** 以下文字适用于 2020 年 5 月 25 日发布的 CosmWasm 0.8.如果您想利用组合的力量，请升级.

## 术语

在本文的其余部分，我将在“合同”和“本机模块”之间做出关键区分. “合同”是 CosmWasm 代码，它是
动态上传到给定地址的区块链.这可以在事后添加并且与任何运行时实现无关.
“原生模块”基本上是 Go Cosmos SDK 模块，它们被编译成区块链二进制文件.这些是相对静态的(需要一个
要添加或修改的软或硬分叉)并且在运行 CosmWasm 的不同区块链之间会有所不同.

我们支持两种类型之间的组合，但我们必须更深入地研究与“本机模块”的集成，因为使用它们可以
导致 [可移植性](#portability) 问题.为了尽量减少这个问题，我们提供了一些关于“模块”的抽象

## 消息

`init` 和 `handle` 都可以返回任意数量的
[`CosmosMsg`](https://github.com/CosmWasm/cosmwasm/blob/08717b4c589bbfe59f44bb8cccffb08f63696413/packages/std/src/init_handle.rs#L11-L31)
对象，这些对象将在同一事务中重新调度(从而为合约执行提供原子成功/回滚).
有3类消息:

* `Contract` - 这将使用给定的消息(以序列化形式提供)调用给定的合同地址.它假定调用者有权访问 API 格式.
* [模块接口](#modules) - 这些是任何链都可以支持的标准化接口，以在 * 可移植 * 接口下公开本机模块.
* [`Custom`](#customization) - 这封装了消息类型的依赖链的扩展，以调用自定义本机模块.理想情况下，随着时间的推移，它们应该在同一条链上*不可变*，但它们不提供可移植性保证.

## 查询

从 CosmWasm v0.8 开始，我们现在允许合约对周围的运行时进行同步 *只读 * 查询.
与 [Messages](#messages) 一样，我们有三种基本类型:

* `Contract` - 这将使用给定的消息(以序列化形式提供)查询给定的合同地址.它假定调用者有权访问 API 格式.
* [模块接口](#modules) - 这些是任何链都可以支持的标准化接口，以在 * 可移植 * 接口下公开本机模块.
* [`Custom`](#customization) - 这封装了一个依赖链的扩展来查询自定义原生模块.理想情况下，随着时间的推移，它们应该在同一条链上*不可变*，但它们不提供可移植性保证.

跨合约查询获取合约地址和合约特定格式的序列化`QueryMsg`，同步获取
合约特定格式的二进制序列化返回值.由调用合约来了解适当的格式.
为了简化这一点，我们可以提供一些特定于合约的类型安全包装器，就像我们提供一个简单的
[`query_balance`](https://github.com/CosmWasm/cosmwasm/blob/08717b4c589bbfe59f44bb8cccffb08f63696413/packages/std/src/traits.rs#L95-L105)
方法作为 Trait 提供的 `query` 实现的包装器.

## 模块

为了更好地与原生区块链集成，我们提供了一组标准化的模块接口
这应该在所有 CosmWasm 链中一致地工作.最基本的一个
是对`Bank` 模块，它提供对底层本机令牌的访问.这给了我们 `BankMsg::Send` 以及
`BankQuery::Balance` 和 `BankQuery::AllBalances` 来检查余额和移动代币.

第二个标准化模块是`staking`，它为`Delegate`、`Undelegate`、
`Redelegate` 和 `Withdraw`，以及查询 `Validators` 和 `Delegations`.这些接口旨在支持
大多数 PoS 系统，并且能够在任何 PoS 系统上得到支持，而不仅仅是 Cosmos SDK 当前的 staking 模块.
(所以，如果你为你的链分叉，合约应该仍然有效).

这提供了一种简洁的设计，您可以在其中开发合同，例如.使用 `staking` 模块接口发布 Staking 衍生产品，
并相信同一个合约将在两个不同的区块链上运行，即使它们都是高度定制的并且一个是
在 Cosmos SDK 0.38 上，另一个在 Cosmos SDK 0.39 上(有许多重大更改).这里的缺点是每个模块接口都必须
被添加到堆栈的所有层，这为支持自定义功能提供了一些延迟，我们不能轻松地为每个自定义添加支持
每个基于 Cosmos SDK 的区块链中的模块.

也就是说，我们强烈建议尽可能使用模块接口，并使用 [自定义类型](#customization) 作为临时措施
保持快速的发布周期.我们很高兴与具有具体用例的项目合作，这些用例可以在许多不同的链之间重复使用
添加新的标准化模块接口.也许是为了治理，或者是为了 IBC/轻客户端相关的功能.

请注意，理论上这些模块接口也可以通过合约实现，而不仅仅是本机代码.
例如.如果我们制作了一个标准的“swap”接口，而你的区块链没有原生的“swap”模块，我们可以上传一个受 UniSwap 启发的合约
并以某种方式在 Go 区块链上注册.然后区块链会知道接收交换消息并将其发送到这个自定义合约.
(请注意，这根本没有实现，只是对未来方向的一个想法).

## 定制

许多链都希望允许合约使用他们的自定义 go 模块执行，而不需要通过所有的工作来尝试将其转换为标准化的 [模块接口](#modules) 并等待新的 CosmWasm 版本.对于这种情况，我们在 CosmosMsg 和 QueryRequest 上引入了 Custom 变体.
这里的想法是合约可以定义要包含在“自定义”变体中的类型，并且只需要 Cosmos SDK 应用程序同意
(在 Golang 中)在另一边.合约和区块链编解码器之间的所有代码都将其视为不透明的 json 字节.

标准 CosmWasm 存储库中的演示“反映”合约，
[展示如何使用`CustomMsg`和`CustomQuery`](https://github.com/CosmWasm/cosmwasm/blob/71f643f577184a23b2f1f122531c944f0de94c34/contracts/reflect/src/msg.rs6#L30).你可以看到合约如何[使用`CustomQuery`](https://github.com/CosmWasm/cosmwasm/blob/master/contracts/reflect/src/contract.rs#L94-L101)
调用一些“运行时提供的”代码.对于单元测试，我们可以[模拟运行时查询器](https://github.com/CosmWasm/cosmwasm/blob/master/contracts/reflect/src/testing.rs#L20-L37)，但在已部署的系统中，这应该由 Cosmos SDK 应用程序中的本机 Go 代码提供.

除了琐碎的情况，我们正在与 Terra 合作，将他们的 `swap`、`oracle` 和 `treasury` 模块暴露给他们链上的 CosmWasm 合约.
这些功能需要以不可变的格式公开，在它们的链上永远有效，但不需要可移植性.
更有趣的是能够快速将其原生模块的新功能暴露给其链上的合约.其实这个具体的用法
案例激发了所有重构以确保自定义消息和查询成为可能.

## 设计注意事项

在产生一个可靠的设计时，我们希望 API 满足所有这些要求(或者在真正不可能实现所有这些要求时取得良好的平衡):

### 便携性

同一个合约应该运行在两个不同的区块链上，使用不同的 Golang 模块、不同版本的 Cosmos SDK，或者理想情况下，甚至
基于不同的框架(例如，在 Substrate 上运行).在避免使用“自定义”消息并检查使用的可选功能时，这应该是可能的.
目前的功能是`staking`，它假设一个PoS系统，以及`iterator`，它假设我们可以对存储进行前缀扫描(即它是一个Merkle **Tree**，而不是一个Merkle **Trie** ).

### 不变性

合约是不可变的，并在其字节码中对查询和消息格式进行编码.如果我们允许以原生格式发送 `sdk.Msg`
(无论是 json、amino 还是 protobuf)，如果本地消息的格式发生变化，那么合约就会中断.
这可能意味着质押模块永远无法解除代币的委托.如果您认为这是一个理论问题，请注意每个专业
Cosmos SDK 的更新产生了如此重大的变化，并为它们进行了迁移.无法在不可变合约上执行的迁移.
因此，我们需要确保我们的设计为潜在的可变运行时提供了一个不可变的 API，这是一个主要的设计标准
设计标准的[模块接口](#modules).

### 可扩展性

我们应该能够向合约和区块链添加新接口，而无需更新任何中间层.那是，
如果你正在构建一个自定义的 `superd` 区块链应用程序，它从 `wasmd` 导入 `x/wasm`，并且想要在它上面开发合约
调用您的自定义 `superd` 模块，然后在理想情况下，您可以将这些消息类型添加到额外的 `cw-superd` 库中
你可以在你的合约中导入，并在 `superd` Go 代码中向它们添加回调. *在`cosmwasm-std`、`cosmwasm-vm`中没有任何变化*，
`go-cosmwasm` 或 `wasmd` 存储库(与您的应用程序具有不同的发布周期).

我们为 `CosmosMsg` 和 `QueryRequest` 提供了 [`Custom`](#customization) 变体来启用这种情况.它们可以提供不变性，但不能
可移植性.

## 可用性

我们还想让将合约组合成一个更大的整体不仅安全且*可能*，而且从开发人员的角度来看使其变得简单.
这适用于合约作者以及将 CosmWasm 集成到他们的自定义区块链中的区块链开发人员.
我们希望使用合约轻松构建客户端应用程序.

我们对 CosmWasm 消息使用 JSON 编码来简化这个过程，并为每个合约导出 [JSON 模式](https://github.com/CosmWasm/cosmwasm-examples/tree/master/erc20/schema) 以允许自动生成客户端编解码器.我们还提供 [CosmJS](https://github.com/CosmWasm/cosmjs)
作为易于使用的 TypeScript 客户端库，允许访问基于 CosmWasm 的链上的所有合约(和银行模块).

### 检查支持

如果我们想调用一些扩展，比如“Staking”模块，我们可以编译我们的合约来处理它.但是我们如何检测区块链
可以支持吗？我们希望在上传或实例化合约时失败，并且不会发现某些关键功能在此链上不起作用，
当合约中存储了价值时.

设计决定是让您使用作为 wasm 导出函数公开的功能标志来配置合约需要哪些额外功能.
这让主链在允许上传之前检查兼容性.为此，我们进行了一些“幽灵”导出，例如
`requires_staking()` 或 `requires_terra()`.如果运行时也暴露了这些特性，这只会通过兼容性检查.
在实例化 `x/wasm.NewKeeper()` 时，您可以指定支持哪些功能.

### 类型安全包装器

在查询或调用其他合约时，我们放弃了使用本机模块接口获得的所有类型检查.
他们要求来电者了解来电者的详细信息.这与以太坊相同.但是，我们可以提供一些“接口”
合约可以导出的包装器，以便其他合约可以轻松调用它.

For example:

```rust
pub struct NameService(CanonicalAddr);

impl NameService {
    pub fn query_name(deps: &Extern, name: &str) -> CanonicalAddr { /* .. */ }
    pub fn register(api: &Api, name: &str) -> CosmosMsg { /* .. */ }
}
```

与其在我们的配置中只存储另一个合约的 CanonicalAddr ，我们还可以存储 NameService ，它是
零成本 ["newtype"](https://doc.rust-lang.org/stable/rust-by-example/generics/new_types.html)
在原始地址之上，具有相同的序列化格式. 然而，它将为我们提供
一些类型安全的助手来查询合约，以及生成`CosmosMsg` 进行注册.

请注意，这些类型安全的包装器与合约的 *实现* 无关，而是与合约的 *接口* 相关联.
因此，我们可以创建一个小型库，其中包含一系列标准/流行的接口(如 ERCxxx 规范)，用此类表示
“新类型”. 合约创建者可以导入这些包装器之一，然后轻松调用合约，无论实现如何，
只要它支持正确的接口
