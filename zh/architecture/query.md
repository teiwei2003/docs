# 查询合约状态

在很多情况下，您希望查看合同的状态。既可以作为外部客户端(使用 cli)，也可以在执行合同时。例如，我们在上一节讨论了解析像“Alice”或“Bob”这样的名字，这需要查询另一个合约。我们将首先介绍两种类型的查询 - 原始查询和自定义查询 - 然后查看通过 *外部客户端 * 以及 *内部客户端 *(另一个合约)进行查询的语义。我们不仅会特别关注它的实际工作方式，还会特别关注从一个合约到另一个合约执行查询的设计和安全问题。

**注意** 这已针对 CosmWasm 0.8 进行了更新，完全支持跨合约查询。

## 原始查询

要实现的最简单查询只是对键值存储的原始读取访问。如果调用者(外部客户端或其他合约)传入合约存储中使用的原始二进制密钥，我们可以轻松返回原始二进制值。这种方法的好处是非常容易实现和通用。缺点是它将调用者链接到存储的*实现*，并且需要知道正在执行的确切合同。

这是在 `wasmd` 运行时内实现的，并绕过 VM。因此，它不需要 CosmWasm 合约的支持，并且所有合约状态都是可见的。这样的 `query_raw` 函数暴露给所有调用者(外部和内部)。

## 自定义查询

在很多情况下，与*实现*紧密耦合是不可取的，我们宁愿依赖*接口*。例如，我们将为调用合约的“ERC20”`HandleMsg`定义一个标准，并且我们希望为`QueryMsg`定义这样一个标准。例如，按地址查询余额，通过授予者+被授予者查询津贴，查询代币信息(代码、小数等)。通过定义标准*接口*，我们允许许多实现，包括复杂的合约，其中“ERC20”接口只是其功能的一小部分。

为了启用自定义查询，我们允许每个合约公开一个 `query` 函数，该函数可以以只读模式访问其数据存储。它可以加载任何它想要的数据，甚至可以对其进行计算。此方法公开为`query_custom` 以调用调用者(外部和内部)。数据格式(查询和响应)是合约需要的任何格式，并且应该与 `HandleMsg` 和 `InitMsg` 一起记录在公共模式中。

请注意，执行合约可能会消耗无限量的 gas。尽管 `query_raw` 将读取一个键并且成本很小，而且大部分是固定的，我们需要对这些查询强制执行 gas 限制。这对于外部和内部调用的处理方式不同，将在下面讨论。

## 外部查询

外部查询是所有 web 和 cli 客户端使用区块链的典型方式。他们调用 Tendermint RPC，后者调用 Cosmos SDK 中的“abci_query”，后者委托给模块来处理它。据我所知，查询有一个无限的gas限制，因为它们只在一个节点上执行，并且不能减慢整个区块链的速度。此功能通常不会在验证节点上公开。当前 SDK 中公开的查询功能是硬编码的，并且具有开发人员设计的执行时间限制。这限制了滥用。但是如果有人上传一个无限循环的 wasm 合约，然后使用它来 DoS 任何公开查询的公共 RPC 节点呢？

为了避免此类问题，我们需要为所有外部调用的 `query_custom` 交易定义一些固定的 gas 限制。这不会收取费用，但用于限制滥用。但是，很难定义标准值，因为免费的公共节点更喜欢少量，但我可能希望同步我自己的存档节点并执行复杂的查询。因此，可以在特定于应用程序的配置文件中定义所有 `query_custom` 调用的 gas 限制，每个节点操作员可以自定义该文件，并具有合理的默认限制。这将允许公共节点保护自己免受复杂查询的影响，同时仍然允许可选查询对特殊配置的节点中的所有合约数据执行大量聚合。

请注意，`abci_query` 调用永远不会读取模块的当前“进行中”状态，而是使用最后提交块之后状态的只读快照。

## 内部查询

虽然合约之间的许多交互可以通过发送消息轻松建模，但在某些情况下，我们希望同步查询其他模块，而不改变它们的状态。例如，如果我想将名称解析为 [规范地址](./addresses#canonical-addresses)，或者如果我想在启用某些操作之前检查某个帐户(在另一个合约中)的 KYC 状态。可以将其建模为一系列消息，但它非常复杂，并且使得这种简单的用例在系统中几乎无法使用。

但是，这种设计违反了 [actor 模型](./actor) 的基本原则之一，即每个合约都可以独占访问其自己的内部状态。 (在这方面，`query_raw` 和`query_custom` 都失败了)。这不仅仅是一个理论上的问题，如果处理不当，这可能会导致并发和重入问题。我们不想把这种安全关键推理推到合约开发者的圈子里，而是在平台中提供这些安全保证。然而，提供旧数据也会导致许多可能的错误和错误，特别是因为我们使用相同的`Querier` 接口
与原生 SDK 模块交互，*包括查询合约自身的余额*。

因此，我们在执行当前 CosmWasm 消息*之前为“查询器”提供了对状态快照的只读访问权限。由于我们采取
快照，并且正在执行的合约和被查询的合约都具有*在合约执行之前*的数据的只读访问权限，这仍然是
使用 Rust 的借用规则是安全的(作为安全设计的占位符)。当前合约只写入缓存，成功后刷新。

另一个问题是避免重入。由于这些查询是同步调用的，它们可以回调到调用合约中并可能导致问题。由于查询只有只读访问权限并且不会产生副作用，因此这不像同步执行远程合约那么危险，但仍然可能是一个需要考虑的问题。值得注意的是，它只能访问当前执行之前的状态。我看不到比查询函数有意返回错误数据会导致更多错误的地方，但这是一个可以进行更多调查的地方。

由于所有查询都是作为交易的一部分执行的，这已经有一个严格执行的 gas 限制，我们在这里不需要额外的工作。作为查询的一部分执行的所有存储读取和数据处理都从与交易的其余部分相同的燃气表中扣除，从而限制了处理时间。我们考虑添加显式保护以防止重入或最大查询深度，但尚未在 `wasmd` 中强制执行它们。随着更多关于跨合约查询的工作取得成果，这是另一个需要调查的地方。
