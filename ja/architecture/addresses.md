# 名前と住所

ブロックチェーン(ほぼ？)は、アドレスを使用して公開鍵のハッシュを介して外部参加者を識別します。多くの新しいブロックチェーンは、これを拡張して、一意のアドレスを持つチェーン上の「スマートコントラクト」を識別します。チェーン上では、アドレスは簡潔で不変のバイナリ形式で表され、通常は20バイトまたは32バイトの長さであり、通常はハッシュ関数から取得されます。ただし、これらのバイナリアドレスには、クライアントに表示される人間が読める形式の表現が多数あります。たとえば、[Bech32](https://en.bitcoin.it/wiki/Bech32) `bc1qc7slrfxkknqcq2jevvvkdgvrt8080852dfjewde450xdlk4ugp7szw5tk9`、https://en.bitcoin.it/wiki/Bech32)` bc1qc7sl .it/wiki/Bech32` EIPS/eip-55.md) `0x5aAeb6053F3E94C9b9A09f33669435E7Ef1BeAed`、さらに[大きな整数](https://research.kudelskisecurity.com/2018/01/16/blockchains-how-to-in-steal -6操作/) `3040783849904107057L`。

## 住所

Cosmos SDKのアドレスは20文字の文字列であり、Bech32のチェーンプレフィックス、Bech32のチェックサム、16進数のチェックサム(EIP55)などのセキュリティチェックが含まれています。
CosmWasmはCosmosSDKの拡張であるため、同じアドレスルールに従います。ウォレット、スマートコントラクト、モジュールはすべて、定義されたプレフィックスを持つ識別子アドレスを持っています。 `cosmos1 ...`はgaiaに使用され、 `wasm1 ...`はCosmWasmテストネットに使用されます。

アドレスをコントラクトに渡すには、それを文字列として渡し、入力を次の1つに確認します。** Addr **
[Addr](https://github.com/CosmWasm/cosmwasm/blob/v0.14.0/packages/std/src/addresses.rs#L31)は単純な文字列のラッパーであり、文字などの便利な補助関数を提供します文字列はアドレスに対して検証されます。

## オプション:正規アドレス

人間の表現が変化する状況を解決できる別の種類の住所表現がありますが、これはまれです。

たとえば、ビットコイン[Base58からBech32への移行](https://en.bitcoin.it/wiki/BIP_0173)はSegWitと一緒にコーディングされており、Riseも[Lisk形式からBech32への移行](https://Medium .com/rise-vision/introducing-rise-v2-521a58e1e9de#41d5)v2アップグレード。

つまり、 `message.signer`が常にトランザクションに署名するための文字列アドレスであり、アカウントの残高を見つけるためにそれを使用する場合、このコードが変更されると、アカウントにアクセスできなくなります。明らかに、内部で使用するための安定した識別子が必要です。

ここで*正規アドレス*を定義します。これは、安定していて一意であると定義されています。つまり、特定のアカウントに対して、(ブロックチェーンのライフサイクル内で)正規のアドレスは1つだけです。複数の文字列アドレスをこの形式に変換できる*正規アドレス*形式を定義しました。変更なしで前後に変換できます

*正規アドレス*は、ブロックチェーンの内部で使用されるバイナリ表現として定義されています。これはネイティブトークンのインデックスベースであるため、アカウントの存続期間中は変更しないでください。これは、すべての**ストレージルックアップ**に使用できる表現です(アドレスの一部をストレージのキーとして使用する場合)。

## 名前

ますます、[人間](https://app.ens.domains/about)[読み取り可能](https://docs.blockstack.org/core/naming/introduction.html)[名前](https://iov.one)は、ブロックチェーン[およびその他]でますます重要になっています(https://hackernoon.com/everything-you-didnt-know-about-the-handshake-naming-system-how-this-blockchain -project -will- 483464309f33)。

昔々、私たちはCosmWasmの第一級市民として名前を付け、メッセージのいたるところにそれらを使用することを検討しました。アカウントが初期化される前に名前を付けることができないことに気付くまで、永続的で安定した*アドレス*が必要です。ただし、その名前が可能な限りブロックチェーンのコアになることを願っています。この目的のために、名前を* Address *の別の形式と考えることができますが、解決するには、純粋関数の呼び出しだけでなく、(ストレージアクセス権を持つ)コントラクトクエリが必要です。

実際のフォーマットとインターフェースはまだ議論中であり、私たちはまだ[ネームサービスのチュートリアルバージョン](../learn/name-service/intro)に取り組んでいます。ただし、議論のために、 `:`で始まる各* Address *はネームサービスによって検索される名前であり、他の* Address *は組み込みのブロックチェーン解決関数を使用して直接解決できることに同意するとします。したがって、エスクローのトランザクションを作成するときは、 `{" arbiter ":" cosmos1qqp837a4kvtgplm6uqhdge0zzu6efqgujllfst "}`または `{" arbiter ":":alice "}`を使用して、クライアント内だけでなく、コントラクト内で解析を実行できます。もちろん、ネームサービスには標準のクエリ形式が必要であり、呼び出し側のコントラクトは、何らかの方法で解決される正規のネームサービスコントラクトのアドレスを知っている必要があります。そのため、この機能についてはまだ検討中です。

### やりました

*注:これは完全に実装するのに長い時間がかかる場合があります。デザインのインスピレーションとして機能します*

ネームサービスの問題の解決策を開発したら、*人間の名前*の可能性を想像し続けましょう。参照を使用してユーザーアドレスを解決できるだけでなく、契約も解決できます。たぶん、名前ではなく、*一意の登録済みトークンコード*で「ERC20」トークンコントラクトにメッセージを送信できます。名前のスコープまたはコンテキストを区別するために、まもなく何らかの方法を使用する必要があります。ここで、[分散識別子(DID)](https://www.w3.org/TR/did-core/)が役立ちます。次のメッセージ形式を想像してみてください。これは、ターミナルクライアントまたはスマートコントラクトによって「アクター」になる可能性があります。

```json
{
    "destination": "did:token:XRN",
    "msg": {
        "transfer": {
            "from": "did:account:alice",
            "to": "did:account:bob",
            "amount": "13.56"
        }
    }
}
```

これは、クライアント側で解析される仕様ではなく、ブロックチェーンで使用される実際の交換形式です。 したがって、スマートコントラクトは実行中にそのようなメッセージを送信することもできます。 あなたはこの考えが好きですか？ コメント？ [githubについての考えを追加してください](https://github.com/CosmWasm/cosmwasm/issues/80)。
