# 契約構成

メッセージを送信する[Actormodel](./actor)と、CosmWasm v0.8に実装されている[synchronous query](./query)を考えると、元のコンポーネントはすべて揃っています。
他のコントラクトおよびネイティブモジュールとのコントラクトの任意の組み合わせが可能です。ここでは、これらのコンポーネントをどのように組み合わせるか、およびそれらを拡張する方法について説明します。

**注**次のテキストは、2020年5月25日にリリースされたCosmWasm0.8に適用されます。組み合わせの力を使いたい場合は、アップグレードしてください。

## 用語

この記事の残りの部分では、「コントラクト」と「ネイティブモジュール」を大きく区別します。 「コントラクト」はCosmWasmコードであり、
特定のアドレスのブロックチェーンへの動的アップロード。これは事後に追加でき、ランタイム実装とは何の関係もありません。
「ネイティブモジュール」は基本的にGoCosmos SDKモジュールであり、ブロックチェーンバイナリファイルにコンパイルされます。これらは比較的静的です(
追加または変更されるソフトフォークまたはハードフォーク)であり、CosmWasmを実行している異なるブロックチェーン間で異なります。

2つのタイプの組み合わせをサポートしますが、「ネイティブモジュール」を使用すると、それらを使用できるため、より深く統合を検討する必要があります。
[portability](#portability)の問題が発生します。この問題を最小限に抑えるために、「モジュール」に関するいくつかの抽象化を提供します

## 情報

`init`と` handle`はどちらも、任意の数を返すことができます
[`CosmosMsg`](https://github.com/CosmWasm/cosmwasm/blob/08717b4c589bbfe59f44bb8cccffb08f63696413/packages/std/src/init_handle.rs#L11-L31)
同じトランザクションで再スケジュールされるオブジェクト(したがって、コントラクト実行のアトミックな成功/ロールバックを提供します)。
メッセージには次の3種類があります。

* `Contract`-これは、指定されたメッセージ(シリアル化された形式で提供)を使用して、指定された契約アドレスを呼び出します。呼び出し元がAPI形式にアクセスできることを前提としています。
* [モジュールインターフェイス](#modules)-これらは、*ポータブル*インターフェイスでネイティブモジュールを公開するためにチェーンがサポートできる標準化されたインターフェイスです。
* [`Custom`](#customization)-これは、カスタムネイティブモジュールを呼び出すためのメッセージタイプの依存関係チェーンの拡張をカプセル化します。理想的には、それらは時間の経過とともに同じチェーン上で*不変*である必要がありますが、移植性の保証は提供されません。

## お問い合わせ

CosmWasm v0.8以降、コントラクトが*読み取り専用*クエリを周囲のランタイムに同期できるようになりました。
[メッセージ](#messages)と同様に、3つの基本的なタイプがあります。

* `Contract`-これは、指定されたメッセージ(シリアル化された形式で提供)を使用して、指定された契約アドレスを照会します。呼び出し元がAPI形式にアクセスできることを前提としています。
* [モジュールインターフェイス](#modules)-これらは、*ポータブル*インターフェイスでネイティブモジュールを公開するためにチェーンがサポートできる標準化されたインターフェイスです。
* [`Custom`](#customization)-これは、カスタムネイティブモジュールをクエリするための依存関係チェーンの拡張をカプセル化します。理想的には、それらは時間の経過とともに同じチェーン上で*不変*である必要がありますが、移植性の保証は提供されません。

契約アドレスと契約固有の形式のシリアル化された `QueryMsg`を取得し、同期的に取得するための相互契約クエリ
コントラクト固有の形式のバイナリシリアル化された戻り値。適切なフォーマットを理解するのは、呼び出し側の契約次第です。
これを単純化するために、単純なものを提供するのと同じように、いくつかのコントラクト固有のタイプセーフラッパーを提供できます。
[`query_balance`](https://github.com/CosmWasm/cosmwasm/blob/08717b4c589bbfe59f44bb8cccffb08f63696413/packages/std/src/traits.rs#L95-L105)
このメソッドは、Traitによって提供される `query`の実装のラッパーとして機能します。

## モジュール

ネイティブブロックチェーンとの統合を強化するために、標準化されたモジュールインターフェイスのセットを提供します
これは、すべてのCosmWasmチェーンで一貫して機能するはずです。最も基本的なもの
基盤となるネイティブトークンへのアクセスを提供する `Bank`モジュールへのアクセスです。これにより、 `BankMsg :: Send`と
残高とモバイルトークンをチェックするための `BankQuery :: Balance`と` BankQuery :: AllBalances`。

2番目の標準化されたモジュールは `stakeing`で、これは` Delegate`、 `Undelegate`、
`Redelegate`と` Withdraw`、そして `Validators`と` Delegations`をクエリします。これらのインターフェースは、
ほとんどのPoSシステムは、Cosmos SDKの現在のステーキングモジュールだけでなく、任意のPoSシステムでサポートできます。
(したがって、チェーンをフォークした場合でも、契約は有効であるはずです)。

これにより、たとえば契約を作成できるクリーンな設計が提供されます。 「ステーキング」モジュールインターフェースを使用して、ステーキングデリバティブ商品をリリースします。
また、同じ契約が2つの異なるブロックチェーンで実行されると考えてください。両方とも高度にカスタマイズされており、一方が
Cosmos SDK 0.38では、もう1つはCosmos SDK 0.39にあります(多くの重大な変更があります)。ここでの欠点は、すべてのモジュールインターフェイスが
スタックのすべてのレイヤーに追加されます。これにより、カスタム機能をサポートするための遅延が発生します。各カスタマイズのサポートを簡単に追加することはできません。
CosmosSDKに基づくブロックチェーンの各モジュール。

つまり、モジュールインターフェイスを可能な限り使用し、一時的な手段として[custom type](#customization)を使用することを強くお勧めします。
速いリリースサイクルを維持します。多くの異なるチェーンで再利用できる特定のユースケースのプロジェクトに喜んで取り組んでいます
新しい標準化されたモジュールインターフェイスを追加します。おそらく、それはガバナンス、またはIBC/ライトクライアント関連の機能のためです。

理論的には、これらのモジュールインターフェイスは、ネイティブコードだけでなく、コントラクトを介して実装することもできることに注意してください。
例えば。標準の「スワップ」インターフェースを作成し、ブロックチェーンにネイティブの「スワップ」モジュールがない場合は、UniSwapに触発されたコントラクトをアップロードできます。
そして、どういうわけかGoブロックチェーンに登録します。次に、ブロックチェーンは交換メッセージを受信し、それをこのカスタムコントラクトに送信することを認識します。
(これはまったく達成されていないことに注意してください、それは将来の方向性のアイデアにすぎません)。

## カスタムメイド

多くのチェーンは、標準化された[モジュールインターフェイス](#modules)に変換して新しいCosmWasmバージョンを待つことなく、カスタムgoモジュールを使用してコントラクトを実行できるようにしたいと考えています。この状況のた​​めに、CosmosMsgとQueryRequestにカスタムバリアントを導入しました。
ここでの考え方は、コントラクトが「カスタム」バリアントに含まれるタイプを定義でき、CosmosSDKアプリケーションが同意することだけを要求するということです。
(Golangで)反対側。コントラクトとブロックチェーンコーデックの間のすべてのコードは、不透明なjsonバイトとして扱います。

デモは、標準のCosmWasmリポジトリの契約を「反映」します。
[`CustomMsg`と` CustomQuery`の使用方法を示します](https://github.com/CosmWasm/cosmwasm/blob/71f643f577184a23b2f1f122531c944f0de94c34/contracts/reflect/src/msg.rs6#L30)。契約が[`CustomQuery`を使用して]どのように行われるかを確認できます(https://github.com/CosmWasm/cosmwasm/blob/master/contracts/reflect/src/contract.rs#L94-L101)
「実行時に提供される」コードを呼び出します。単体テストの場合、[ランタイムクエリャーをシミュレート](https://github.com/CosmWasm/cosmwasm/blob/master/contracts/reflect/src/testing.rs#L20-L37)できますが、システムにデプロイされています、これはCosmosSDKアプリケーションのネイティブGoコードによって提供される必要があります。

些細な状況を除いて、Terraと協力して、 `swap`、` oracle`、および `treasury`モジュールをオンチェーンのCosmWasmコントラクトに公開しています。
これらの関数は不変の形式で開示する必要があり、チェーン上で常に有効ですが、移植性は必須ではありません。
さらに興味深いのは、ネイティブモジュールの新しい機能をチェーン上のコントラクトにすばやく公開する機能です。実際、この特定の使用法
このケースは、カスタムメッセージとクエリが可能であることを保証するためにすべてのリファクタリングに影響を与えました。

## 設計上の考慮事項

信頼性の高い設計を作成する場合、APIがこれらすべての要件を満たすことを望んでいます(または、これらすべての要件を達成することが本当に不可能な場合は、バランスをとってください)。

### 移植性

同じコントラクトは、異なるGolangモジュール、異なるバージョンのCosmos SDKを使用して、2つの異なるブロックチェーンで実行する必要があります。理想的には、
さまざまなフレームワークに基づいています(たとえば、Substrateで実行されています)。これは、「カスタム」メッセージを回避し、使用されているオプション機能を確認するときに可能になるはずです。
現在の関数は、PoSシステムを想定した `stakeing`と、ストレージでプレフィックススキャンを実行できることを前提とした` iterator`です(つまり、Merkle ** Trie *ではなくMerkle ** Tree **です。 *)。

### 不変性

コントラクトは不変であり、クエリとメッセージの形式をバイトコードにエンコードします。ネイティブ形式での `sdk.Msg`の送信を許可する場合
(json、amino、protobufのいずれであっても)ローカルメッセージの形式が変更されると、コントラクトは中断されます。
これは、誓約モジュールがトークンを廃止できないことを意味する場合があります。これが理論的な質問だと思われる場合は、各専攻に注意してください。
Cosmos SDKのアップデートにより、このような重要な変更が行われ、移行されました。不変の契約では実行できない移行。
したがって、主要な設計基準である潜在的に可変のランタイムに対して、設計が不変のAPIを提供することを確認する必要があります。
設計基準[モジュールインターフェース](#modules)。

### スケーラビリティ

中間層を更新せずに、コントラクトとブロックチェーンに新しいインターフェイスを追加できるはずです。あれは、
カスタムの `superd`ブロックチェーンアプリケーションを構築している場合は、` wasmd`から `x/wasm`をインポートし、その上でコントラクトを開発する必要があります
カスタムの `superd`モジュールを呼び出すと、理想的には、これらのメッセージタイプを追加の` cw-superd`ライブラリに追加できます。
それらをコントラクトにインポートし、 `superd`Goコードでそれらにコールバックを追加できます。 * `cosmwasm-std`、` cosmwasm-vm`、
`go-cosmwasm`または` wasmd`リポジトリ(アプリケーションとはリリースサイクルが異なります)。

この状況を有効にするために、 `CosmosMsg`および` QueryRequest`の[`Custom`](#customization)のバリアントを提供します。それらは不変性を提供できますが、できません
移植性。

## 可用性

また、契約の組み合わせを、安全で*可能*であるだけでなく、開発者の観点からも単純なものにしたいと考えています。
これは、CosmWasmをカスタムブロックチェーンに統合する契約作成者およびブロックチェーン開発者に適用されます。
コントラクトを使用して、クライアントアプリケーションを簡単に構築したいと考えています。

このプロセスを簡素化するためにCosmWasmメッセージにJSONエンコーディングを使用し、契約ごとに[JSON Schema](https://github.com/CosmWasm/cosmwasm-examples/tree/master/erc20/schema)をエクスポートして、顧客の自動生成を可能にしますコーデックを終了します。 [CosmJS](https://github.com/CosmWasm/cosmjs)も提供しています
使いやすいTypeScriptクライアントライブラリとして、CosmWasmベースのチェーン上のすべてのコントラクト(およびバンキングモジュール)にアクセスできます。

### サポートを確認する

「ステーキング」モジュールなどの一部の拡張機能を呼び出したい場合は、それを処理するためにコントラクトをコンパイルできます。しかし、どのようにしてブロックチェーンを検出しますか
あなたはそれをサポートできますか？コントラクトをアップロードまたはインスタンス化するときに失敗することを望んでおり、特定の主要な機能がこのチェーンで機能しないことはわかりません。
値が契約に保存されている場合。

設計上の決定は、wasmエクスポート機能として公開されている機能フラグを使用して、コントラクトに必要な追加機能を構成することです。
これにより、メインチェーンはアップロードを許可する前に互換性を確認できます。この目的のために、次のようないくつかの「ゴースト」エクスポートを実行しました。
`requires_staking()`または `requires_terra()`。これらの機能が実行時にも公開されている場合、これは互換性チェックにのみ合格します。
`x/wasm.NewKeeper()`をインスタンス化するときに、サポートされる関数を指定できます。

### タイプセーフラッパー

他のコントラクトを照会または呼び出すときに、ネイティブモジュールインターフェイスを使用して取得したすべての型チェックを放棄しました。
彼らは発信者に発信者の詳細を知るように頼みます。これはイーサリアムと同じです。ただし、いくつかの「インターフェース」を提供することはできます
他のコントラクトが簡単に呼び出すことができるように、コントラクトがエクスポートできるラッパー。

For example:

```rust
pub struct NameService(CanonicalAddr);

impl NameService {
    pub fn query_name(deps: &Extern, name: &str) -> CanonicalAddr {/* .. */}
    pub fn register(api: &Api, name: &str) -> CosmosMsg {/* .. */}
}
```

別のコントラクトのCanonicalAddrのみを構成に保存する代わりに、NameServiceを保存することもできます。
ゼロコスト["newtype"](https://doc.rust-lang.org/stable/rust-by-example/generics/new_types.html)
元のアドレスの上では、同じシリアル化形式になっています。 しかし、それは私たちに提供します
契約を照会し、登録用の `CosmosMsg`を生成するタイプセーフアシスタント。

これらのタイプセーフラッパーは、コントラクトの*実装*とは関係ありませんが、コントラクトの*インターフェース*に関連していることに注意してください。
したがって、このクラスで表される一連の標準/人気のあるインターフェイス(ERCxxx仕様など)を含む小さなライブラリを作成できます。
"新しいタイプ"。 コントラクトの作成者は、これらのラッパーの1つをインポートして、実装に関係なく、コントラクトを簡単に呼び出すことができます。
正しいインターフェースをサポートしている限り
