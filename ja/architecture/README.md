## Solidity契約との比較

まず、展開-実行プロセスは、2つのステップではなく3つのステップで構成されます。イーサリアムは多くのユニークな契約の概念に基づいて構築されていますが、各契約は任意の二国間契約に合わせてカスタマイズできますが、現実には、エラーなしで契約を書くことは当初考えられていたよりも難しく、それらのほとんどは標準です。 OpenZepellinなどのテンプレート。これを念頭に置き、wasmコードのアップロードと検証のオーバーヘッドを認識して、契約の次の3つのフェーズを定義しました。

*コードのアップロード-州と契約アドレスのない最適化されたwasmコードをアップロードします(例:標準のERC20契約)
*コントラクトをインスタンス化します-初期状態を使用してコード参照をインスタンス化し、新しいアドレスを作成します(たとえば、* my * ERC20トークンのトークン名、最大発行量などを設定します)。
*実行コントラクト-これは多くの異なる呼び出しをサポートする可能性がありますが、コントラクトの設計に応じて、以前にインスタンス化されたコントラクトの非特権的な使用です(たとえば、ERC20トークンの送信、他のコントラクトの承認の付与)

イーサリアムと同様に、契約のインスタンス化と実行は計測され、ガスが必要です。さらに、インスタンス化と実行の両方により、署名者はメッセージと一緒にいくつかのトークンをコントラクトに送信できます。たとえば、2つの主な違いは、トークンをコントラクトに直接送信することです。 `SendMsg`を使用すると、可能ではありますが、*コントラクトコードはトリガーされません*。これは、考えられる攻撃ベクトルを減らすことができる明確な設計上の決定です。不可能なことは何もありませんが、すべての契約の履行が*明らかに必要*である必要があります。

## 再突入攻撃を回避する

もう1つの大きな違いは、設計上、すべての再入可能な攻撃を回避することです。これは別の記事を書く価値がありますが、要するに[イーサリアムの脆弱性の大規模なクラスはこの手法に基づいています](https://consensys.github.io/smart-contract-best-practices/known_attacks/)。アイデアは、コントラクトAで関数を実行しているときに、2番目のコントラクトを(明示的または暗黙的に送信することによって)呼び出すというものです。これにより、制御がコントラクトBに移り、コントラクトBはコードを実行して、コントラクトAを再度呼び出すことができます。現在、2つのコントラクトAが実行されています。リモートコントラクトを実行する前に、状態を非常に注意深く管理するか、サブコールで非常に厳しいガス制限を設定しない限り、コントラクトAで未定義の動作がトリガーされる可能性があり、スマートハッカーはDAOハッキングなどのエクスプロイトの基礎としての再入国。

Cosmwasmは、契約が別の契約を直接呼び出すことを防ぐことにより、この状況を完全に回避します。明らかに、合成を許可したいのですが、悪意のあるコードへのインライン関数呼び出しは、セキュリティの悪夢を引き起こします。 CosmWasmで採用されている方法は、すべてのコントラクトがメッセージのリストを*同じトランザクションで*実行*できるようにすることです。これは、契約が完了後に配信を要求する(たとえば、エスクローを解放する)か、他の契約を呼び出すことができることを意味します。今後のメッセージが失敗した場合、契約ステータスの更新を含むトランザクション全体が再開されます。これにより、アトミックな組み合わせとかなりのセキュリティ保証が可能になります。唯一の本当の欠点は、別のコントラクトの実行結果を表示できず、「エラー回復」しか実行できないことです。

別のコントラクトからの情報が必要になる場合があります。バージョン0.8では、他のコントラクトまたは基盤となるCosmosSDKモジュールに同期クエリを追加しました。これらのクエリは、読み取り専用のデータベーススナップショットにのみアクセスでき、状態を変更したり、他のモジュールにメッセージを送信したりできないため、再入可能性の問題を回避できます。

## リソース制限

エクスプロイト(再突入攻撃など)に加えて、スマートコントラクトの別の攻撃ベクトルはサービス拒否攻撃です。悪意のある攻撃者は、無限ループを実行するコントラクトをアップロードしてチェーンを停止したり、ディスクをいっぱいにするために大量のデータを書き込んだりする可能性があります。 Web Assemblyは、オペレーティングシステムへのデフォルトアクセスのないタイトなサンドボックスを提供するため、スマートコントラクトに厳格なリソース制限を提供することだけを心配する必要があります。すべての開発者は、これらの制限に注意する必要があります。

*メモリ使用量* -WasmVMがインスタンス化されると、デフォルトで32MBのRAMによって提供されます。これは、実行中のプロセス(スタックとヒープ)によって使用されるバイトコードとすべてのメモリを格納するためのものです。ほとんどすべての契約では、これは十分な大きさである必要がありますが、一部の複雑なゼロ知識回路はそこで限界に達する可能性があります。また、コントラクトがブロックチェーンのメモリ使用量に与える影響を最小限に抑えるのに十分な大きさです。

* CPU使用率*-[Wasmerランタイム](https://github.com/wasmerio/wasmer)を使用して、計測ロジックをwasmコードに挿入します。さまざまな操作と料金の価格を計算し、各ジャンプステートメント(ループ、関数呼び出しなど)の前に制限をチェックして、CPU速度、プラットフォームなどに関係なく、決定論的なガス価格を生成します。契約を実行する前に、残りのCosmos SDKガスに基づいてwasmガス制限が設定され、契約の終了時にガスが差し引かれます(現在、100wasmガスを1sdkガスに変換する定数乗数があります)。これにより、使用したサイクルの料金を支払う必要があるため、CPUの計算に厳しい制限が課せられます。

*ディスク使用量*-すべてのディスクアクセスは、KVStoreでの読み取りと書き込みによって行われます。 Cosmos SDKには[KVStoreアクセスの必須ガス支払い](https://github.com/cosmos/cosmos-sdk/blob/4ffabb65a5c07dbb7010da397535d10927d298c1/store/types/gas.go#L154-L162)があります。コントラクト内のすべてのディスクアクセスはSDKへのコールバックを介して行われるため、そこには料金がかかります。 CosmWasmを別のランタイムに統合する場合は、そこへのアクセスに対して課金されていることも確認する必要があります。

## イーサリアムから学んだ教訓

イーサリアムは、すべてのブロックチェーンスマートコントラクトプラットフォームの祖父であり、他のどのプラットフォームよりも多くの使用法と実際の経験を持っています。この知識を過小評価することはできませんが、彼らの成功と失敗から学び、より強力なスマートコントラクトプラットフォームを作成します。

彼らは[すべての既知のイーサリアム攻撃ベクトル](https://github.com/sigp/solidity-security-blog)と緩和戦略のリストをまとめました。 Cosmwasmをこのリストと比較して、どれだけの数がこれに当てはまるかを確認します。これらの攻撃ベクトルの多くは、設計により閉じられています。まだいくつかの問題があり、そのような問題を残さないようにする計画があります。

### :heavy_check_mark:[再入可能](https://github.com/sigp/solidity-security-blog#reentrancy)

cosmwasmでは、他のコントラクトを実行するために同じアトミック操作でメッセージを返しますが、*コントラクトが完了した後です。これは参加者モデルに基づいており、リエントラント攻撃の可能性を回避します。コントラクトが呼び出されたときに不安定な状態になることはありません。

### :heavy_check_mark:[算術アンダー/オーバーフロー](https://github.com/sigp/solidity-security-blog#ouflow)

Rustを使用すると、[貨物マニフェスト](https://doc.rust-lang.org/cargo/reference/manifest.html#the-profile-sections)で `overflow-checks = true`を設定するだけで、プログラムを中止できます。オーバーフローが検出されました。安全な数学をオプトアウトできません。

###:警告:[予期しないEther](https://github.com/sigp/solidity-security-blog#ether)

**悪いデザインパターン**

これには、残高の完全な管理に依存する契約が含まれます。契約システムで避けるべきデザインパターン。 CosmWasmでは、トークンをコントラクトに送信するときにコントラクトは呼び出されませんが、呼び出されると、現在の残高を照会できます。 [サンプルホスティングコントラクト](https://github.com/CosmWasm/cosmwasm-examples/blob/escrow-0.4.0/escrow/src/contract.rs)の初期化中に、レコードが送信されなかったことがわかります。はい[現在の残高を解放します](https://github.com/CosmWasm/cosmwasm-examples/blob/escrow-0.4.0/escrow/src/contract.rs#L83-L92)金額を引き出すか払い戻します。これにより、トークンがスタックしなくなります。

### :heavy_check_mark:[Delegate Call](https://github.com/sigp/solidity-security-blog#delegatecall)

CosmWasmにはそのようなデリゲート呼び出しロジックはありません。モジュールをインポートすることはできますが、コンパイル時に相互にリンクされるため、モジュール全体をテストでき、コントラクトロジックに微妙なエントリポイントはありません。

### :heavy_check_mark:[デフォルトの可視性](https://github.com/sigp/solidity-security-blog#visibility)

開発者は、コード内の各関数/メソッドのエントリポイントを自動的に生成するのではなく(さらに悪いことに、指定されていない場合はパブリックと見なされます)、処理するメッセージのリストを明確に定義して、適切な関数にディスパッチする必要があります。このように誤って関数を公開することは不可能です。

### :警告:[エントロピーイリュージョン](https://github.com/sigp/solidity-security-blog#entropy)

**計画された修正**

イーサリアムの鉱夫と比較して、テンダーミントのブロック提案者は、ブロックハッシュ(およびタイムスタンプの最後の桁)を操作するのが簡単です。それらはランダム性のために決して使用されるべきではありません。安全なランダムビーコンを提供し、この安全なエントロピーのソースをスマートコントラクトに公開する計画があります。

### :heavy_check_mark:[外部契約リファレンス](https://github.com/sigp/solidity-security-blog#contract-reference)

**計画の救済**

特定の `HandleMsg`を使用してコントラクトを呼び出す場合、コントラクトに必要なのは指定されたAPIのみですが、そこにはコードの説明はありません。必要なコントラクト(またはAPIのスーパーセット)と同じAPIを使用して悪意のあるコードをアップロードし、直接呼び出すか、コントラクトから呼び出すように依頼できます。これは資金を盗むために使用できます。実際、[チュートリアルで示されています](../learn/hijack-escrow/hack-contract.md)。

2つの緩和策があります。 1つ目は、CosmWasmでは、サイズ制限を処理するために実行時にSolidityライブラリを呼び出す必要はありませんが、必要なすべてのコードをwasmblobにリンクすることをお勧めします。これだけで、外部契約参照の使用のほとんどが排除されます。

もう1つの緩和策は、ユーザーがチェーンのwasm契約の背後にある確認済みの錆の原因をすばやく見つけられるようにすることです。このメソッドは[etherscan](https://medium.com/coinmonks/how-to-verify-and-publish-on-etherscan-52cf25312945#bc72)で使用され、開発者は元のソースコードを公開できます。コンパイルされます。同じバイトコードがチェーン上にある場合、それがこの錆の発生源からのものであることを証明できることがわかります。さびワスムの決定論的ビルドシステムを構築しました。
[元のソースコードを検証するための簡単なツール](https://medium.com/confio/dont-trust-cosmwasm-verify-db1caac2d335)を用意します。
また、[コードブラウザをリリース](https://demonet.wasm.glass/codes)して、契約やローカルを閲覧できるようにしました
1つのコマンドでソースコードを確認します。

### :heavy_check_mark:[短いアドレス/パラメータ攻撃](https://github.com/sigp/solidity-security-blog#short-address)

これは、RLPエンコーディングメカニズムと固定の32バイトスタックサイズを悪用する脆弱性です。タイプチェックのjsonパーサーには適用されません。

### :heavy_check_mark:[チェックされていない呼び出しの戻り値](https://github.com/sigp/solidity-security-blog#unchecked-calls)

CosmWasmは他のコントラクトへの直接呼び出しを許可しませんが、リターンメッセージは後でルーターによってディスパッチされます。ルーターはすべてのメッセージの結果をチェックします。チェーン内の**いずれかの**メッセージがエラーを返した場合、トランザクション全体が中止され、状態の変更がロールバックされます。これにより、他の契約への呼び出しをスケジュールするときに成功事例に安全に集中でき、計画どおりに進まない場合はすべての状態がロールバックされることがわかります。

### :警告:[競合状態/先行実行](https://github.com/sigp/solidity-security-blog#race-conditions)

これは、すべてのブロックチェーンに共通の問題です。ブロックを形成する前に、署名されたメッセージはすべてのノード間で伝播されます。キーマイナー/検証者は、別のトランザクションを作成し、トランザクションの前に挿入できます(トランザクションが遅延する可能性があります)。これは通常問題ではありませんが、分散型取引所で多く発生します。 90で長期の売り注文があり、100で買い注文をした場合、通常は90でしか一致しません。ただし、マイナーは2つの間に2つのトランザクションを挿入できます。1つは90で購入し、もう1つは100で販売し、トランザクションを最後まで遅らせます。あなたは最終的に100の価格で彼らの申し出を受け入れるでしょう、そして彼らは裁定取引のために10トークンの利益を得るだけです。

これは、高頻度取引や、結果を決定するために顧客間の注文に依存するシステムでも問題であり、遅延がマイクロ秒ではなく数秒であるため、ブロックチェーンでより顕著になります。ほとんどのアプリケーションでは、これは問題ではありません。分散型取引所では、たとえば、いくつかの設計があります。バッチオークションは、プリエンプションの可能性を排除します。

### :警告:[サービス拒否](https://github.com/sigp/solidity-security-blog#dos)

**限られた状況**

契約が外部のユーザー定義の入力に依存している場合、それを処理するためにガスが不足するように設定できるという考え方です。多くの状況でCosmWasmに影響を与えることはありません。特に、wasmの実行速度が速く、CPUのガス制限により、1つのトランザクションで多くの処理が可能になるためです(wasmでのed25519署名検証を含み、事前コンパイルは不要です)。ただし、ストレージ内のユーザー制御のキーの数を繰り返すと、すぐにガスが不足します。

### :heavy_check_mark:[タイムスタンプのブロック操作](https://github.com/sigp/solidity-security-blog#block-timestamp)

Tendermintは、すべてのブロックチェーンヘッダーに[BFTタイムスタンプ](https://github.com/tendermint/tendermint/blob/master/docs/spec/blockchain/blockchain.md#time-1)を提供します。これは、タイムスタンプを操作するためにほとんどのバリデーターが共謀する必要があることを意味し、ブロックチェーン自体のように信頼できます。 (同じほとんどの人がチェーンを止めたり、フォークで作業したりできます)

### :heavy_check_mark:[Constructors with Care](https://github.com/sigp/solidity-security-blog#constructors)

これは、コンストラクターの命名を伴うSolidity言語の機能です。 cosmwasmで `init`の名前を変更する可能性は非常に低く、名前を変更すると、バックドアを生成する代わりにコンパイルに失敗します。

### :heavy_check_mark:[初期化されていないストレージポインター](https://github.com/sigp/solidity-security-blog#storage)

CosmWasmは変数を自動的に入力しないため、ストレージから明示的にロードする必要があります。そして、rustは、初期化されていない変数をどこでも使用することを許可しません( `unsafe`ブロックを書き始め、初期化されていないメモリにアクセスするために特別な呼び出しを行わない限り...しかし、問題を求めます)。ストレージを暗黙的ではなく明示的にすることで、このような障害を排除できます。

### :heavy_check_mark:[浮動小数点と精度](https://github.com/sigp/solidity-security-blog#precision)

SolidityもCosmWasmも、丸めの不確実性(CPUによって異なります)のため、浮動小数点演算をサポートしていません。 Solidityは、整数の数学演算を実行する以外に選択肢はありません。多くの開発者は、整数を10進数に手動で近似するため、丸め誤差が発生する可能性があります。

CosmWasmでは、任意のRustパッケージをインポートでき、適切なパッケージを選択して内部で使用するだけです。 [rust_decimal](https://docs.rs/rust_decimal/1.0.3/rust_decimal/)のように、「純粋なRustで記述された小数点以下の実装は、丸め誤差のない重要な整数と小数点以下の桁数を必要とする財務計算に適しています。」。または[ fixed](https://docs.rs/fixed/0.5.0/fixed/)は、固定小数点の小数演算を提供します。最大128桁をサポートします。これは、小数点の前後18桁で十分であり、あらゆるユースケースで十分です。

### :heavy_check_mark:[Tx.Origin認定](https://github.com/sigp/solidity-security-blog#tx-origin)

CosmWasmは `tx.origin`を公開しませんが、コントラクトを公開するか、ユーザーがコントラクトを` params.message.signer`として直接呼び出します。これは、比較する値が1つしかないため、誤った認証に依存することは不可能であることを意味します。
