# 契約によって呼び出されたアクターモデル

[アクターモデル](https://en.wikipedia.org/wiki/Actor_model)は、信頼性の高い分散システムを構築するためによく使用されるデザインパターンです。 私の意見では、基本的なポイントは、各 `Actor`は独自の内部状態に排他的にアクセスでき、` Actors`はいくつかの `Dispatcher`(システム状態を維持)を介してのみ相互に直接呼び出すことはできず、アドレスをコードにマップでき、ストレージ)。 基本的に、 `Actor`パターンは次のようなインターフェースにカプセル化できます。

```rust
pub trait Actor {
    fn handle(msgPayload: &[u8]) -> Vec<Msg>;
}

pub struct Msg {
    pub destination: Vec<u8>,
    pub payload: Vec<u8>,
}
```

これは、CosmWasmでコントラクトをモデル化するために使用される基本モデルです。関数 `pub fn handle <T:Storage>(store:＆mut T、params:Params、msg:Vec <u8>)-> Result <Response>`でも同じ効果が見られます。 `Response`には` Vec <Msg> `といくつかのメタデータが含まれています。 `store`は、契約の内部状態へのアクセスです。 `params`は、グローバルに不変のコンテキストです。したがって、同じデザインの周りに必要な構文はごくわずかです。この基本的な設計から、他のいくつかの有用な側面を引き出すことができます。

まず、アクター間に**緩い結合**があります。これはパケットの形式に制限されます(受信者は送信したスーパーセットをサポートする必要があります)。複雑なAPIまたは関数ポインタを渡すことはできません。これは、サービス間の境界としてRESTまたはRPC呼び出しを使用するのとよく似ています。これは、多くのベンダーのシステムを組み合わせるスケーラブルな方法です。

次に、各 `Actor`は独自のスレッドで効果的に実行でき、独自のキューを持っています。これにより、同時実行性(CosmWasmでは使用していません...)と、各アクターでの**実行のシリアル化**(依存しています)の両方を実現できます。つまり、上記のHandleメソッドは、以前に実行されたHandle呼び出しの途中では実行できません。 `Handle`は同期呼び出しであり、` Actor`が次​​のメッセージを処理する前に戻ります。この機能は[設計による再突入から私たちを保護する](../architecture/smart-contracts#avoiding-reentrancy-attacks)です。

CosmWasmに関連するもう1つの重要な側面は、**局所性**です。つまり、アクターは他のアクターと**以前に受信したアドレス**とのみ通信できます。 [アドレスと名前](./addresss)については次のページで詳しく説明しますが、重要なのは2人の参加者が通信できるようにすることです。外部メッセージ(契約作成者または場合によってはユーザーから)を送信する必要があります。俳優に。これは、分散方式でトポロジを設定するための柔軟な方法です。ハードコーディングする必要があるのは、これらのアドレスに渡されるデータ形式だけです。いくつかの標準インターフェース(ERC20、ERC721、ENSなど)が確立されると、サポートコードは異なりますが、共通のAPIを共有して、主要なタイプのコントラクト間の構成をサポートできます。

## セキュリティ上の利点

**プライベート内部状態**を適用することにより、特定のコントラクトは、その内部状態でのすべての有効な遷移を保証できます。これは、トラステッドモジュールがコンストラクターで「StoreKey」を渡すCosmos SDKで使用される機能モデルとは対照的です。これにより、*別のモジュールのストレージへの完全な読み取りおよび書き込みアクセス*が可能になります。 Cosmos SDKでは、モジュールを呼び出す前にモジュールを監査し、コンパイル時にこのような強力な権限のセットを安全に渡すことができます。ただし、スマートコントラクトシステムにはコンパイル時のチェックがないため、コントラクト間にさらに厳密な境界を作成する必要があります。これにより、コントラクト状態で発生する可能性のあるすべての遷移について完全に推論できます(クイックチェックなどの方法を使用してテストできます)。

上記のように、**シリアル化の実行**は、コントラクトコードのすべての同時実行を防ぎます。これは、契約コード全体の自動ミューテックスロックのようなものです。これは、最も一般的なイーサリアム攻撃、再入可能性、および悪用可能性の問題の1つです。コントラクトAはコントラクトBを呼び出し、コントラクトBはコントラクトAにコールバックします。最初の呼び出しでコントラクトAのメモリにローカルな変更があり(たとえば、残高を差し引く)、それが永続化されていないため、2番目の呼び出しで古い2番目のステートメントを使用できます(たとえば、残高の送信が許可されています)。 2回)。強制的なシリアル化の実行により、コントラクトは終了する前にすべての変更をストレージに書き込み、次のメッセージを処理するときに正しいビューを持ちます。

## アトミック実行

メッセージの送信に関する1つの問題は、両方のコントラクトで状態の変更をアトミックにコミットすることです。多くの場合、ステータスを送信する前に、返されたすべてのメッセージが正しく処理されていることを確認する必要があります。 「3フェーズコミット」のようなアイデアは分散データベースで使用されますが、通常の状況ではすべての参加者が同じバイナリファイルに住んでいるため、この問題は「Keeper」で処理できます。外部トランザクションからメッセージを実行する前に、グローバルデータストレージのSavePointを作成し、サブセットを最初のコントラクトに渡します。次に、返されたすべてのメッセージを同じサブトランザクションで実行します。すべてのメッセージが成功した場合、サブトランザクションをコミットできます。障害が発生した場合(またはガスが不足した場合)、実行を中止し、最初の契約が実行される前の状態にロールバックします。

これにより、エラー処理のロールバックに依存して、コードを楽観的に更新できます。たとえば、取引所が2つの「ERC20」トークン間のトランザクションと一致する場合、オファーを履行して2つのメッセージを返し、トークンAを購入者に転送し、トークンBを販売者に転送できます。 (ERC20トークンはクォータの概念を使用しているため、所有者は取引所が自分のアカウントから最大X個のトークンを転送することを「許可」します)。返されたメッセージを実行すると、購入者が十分なトークンBを持っていない(または提供されたクォータが不十分である)ことがわかります。このメッセージは失敗し、シーケンス全体が復元されます。トランザクションは失敗し、オファーは完了としてマークされず、トークンは変更されませんでした。

多くの開発者は、実行パスで別のコントラクトを直接呼び出してエラーを処理することを検討することを好むかもしれませんが、この*楽観的な更新とリターン*の方法を使用して、ほぼすべて同じ状況を実現できます。また、コントラクトのエラー処理コードにエラーの余地はありません。

## ダイナミックリンクホストモジュール

**局所性**と**緩い結合**の側面は、他のCosmWasmコントラクトにリンクする必要さえないことを意味します。コーディネーターがアドレスを持っているものなら何にでもメッセージを送ることができます。たとえば、 `SendMsg`を返すことができます。これは、CosmosSDKのネイティブ` x/supply`モジュールによって処理されてネイティブトークンを移動します。構成可能性の標準インターフェースを定義するとき、コアモジュールを呼び出すインターフェースを定義し(共有のバインドとバインド解除...)、コントラクトコンストラクターのネイティブモジュールにアドレスを渡すことができます。

## ブロックチェーン間のメッセージ転送

アクターモデルは別のコントラクトへの同期呼び出しを試みず、「実行する」というメッセージのみを返すため、[IBC](https://cosmos.network/ibc)の使用に非常に適しています。ここでの唯一の注意点は、上記で提供した*アトミック実行*の保証がここでは適用されなくなることです。同じスケジューラーによって別の呼び出しが呼び出されることはないため、コントラクト自体に中間状態を格納する必要があります。これは、IBC呼び出しの結果がわかるまで変更できず、安全に適用または復元できる状態を意味します。

たとえば、トークンをチェーンAからチェーンBに移動する場合は、最初に以下を送信する準備をする必要があります。

1.コントラクトAは送信者のトークン供給を減らします
2.コントラクトAは、IBCメッセージID、送信者、および受信者チェーンにリンクされたトークンの「エスクロー」を作成します。
3.コントラクトAはステータスを送信し、チェーンBへのIBCトランザクションを開始するためのメッセージを返します。
4. IBC送信部分が失敗した場合、コントラクトは上記のようにアトミックに復元されます。

一定期間後、「成功」または「エラー」/「タイムアウト」メッセージがIBCモジュールからトークンコントラクトに返されます。

1.コントラクトAは、IBCハンドラー(許可)からのメッセージを検証し、エスクロー内の既知のIBCメッセージIDを参照します。
2.成功した場合は、エスクローを削除し、エスクローされたトークンを「Bチェーン」アカウントに入れます(つまり、Bチェーンからの将来のIBCメッセージのみがそれらを解放する可能性があります)。
3.エラーの場合、エスクローは削除され、エスクローされたトークンは元の送信者のアカウントに返されます。

モバイルNFTの所有権、クロスチェーンの誓約などについても同様のシナリオを想像できます。 Cosmos SDKのIBCコードが安定したら(そしてバージョンに含まれるように)、これらの可能性を拡大し、適切な設計に役立つツールを提供します)が、契約設計ではこれを考慮に入れています。

## クレジット

リエントラント攻撃を回避するためにアクターモデルを使用する設計を提案してくれた[AaronCraelius](https://github.com/aaronc)に感謝します。
