# CW20仕様:代替トークン

cw20パッケージのソースコード:[https://github.com/CosmWasm/cosmwasm-plus/tree/master/packages/cw20](https://github.com/CosmWasm/cosmwasm-plus/tree/master/packages/cw20 ).

CW20は、CosmWasmに基づく代替トークン仕様です.
名前とデザインは、イーサリアムのERC20標準に大まかに基づいています.
しかし、多くの変更が加えられました.ここのタイプは渡すことができます
この仕様の契約を実装することを望んでいる、または呼び出し契約を通じて
標準のcw20契約.

仕様は複数の部分に分かれており、契約は
これらの機能のいくつかは実現されていますが、基本は実現されなければなりません.

::: ヒント
このセクションには、CW20仕様の実装の詳細が含まれています.
契約をしている場合は、
このセクションをスキップして、[次のページ](03-cw20-base-tutorial.md)に移動します
:::

## によると

これは、残高と送金を処理します.すべての金額が
`Uint128`(JSON文字列表現を含む128ビット整数)として処理されます.
小数の処理は、解釈ではなくユーザーインターフェイスに任されています

### 情報

`転送{受信者、金額}`-から
`env.sender`アカウントから` recipient`アカウントへ.これがためのものです
秘密鍵によって制御されているアドレスに送信され、トリガーされない
契約の場合は、受信者に対する操作.

`Send {contract、amount、msg}` -from
`env.sender`アカウントから` recipient`アカウントへ. `契約`は
「Receiver」インターフェースを実装する契約のアドレス. `msg`
金額と一緒に受取人の契約書に渡されます.

`Burn {amount}` -`env.sender`の残高から `amount`トークンを削除します
そして、 `total_supply`を同じ量だけ減らします.

###お問い合わせ

`Balance {address}`-指定されたアドレスの残高を返します.
アドレスが不明な場合は「0」を返します.リターンタイプ
`BalanceResponse {balance}`です.

`TokenInfo {}`-コントラクトのトークン情報を返します.戻りタイプは
`TokenInfoResponse {name、symbol、decimal、total_supply}`.

###受信者

`Send`の対応する部分は` Receive`であり、
CW20トークンの管理を希望する契約.これは通常*ではありません*
CW20契約によって実装されます.

`Receive {sender、amount、msg}` -`Send`を処理するように設計されています
情報.契約アドレスは `env.sender`に保存されます
したがって、偽造することはできません.契約では、送信者が一致することを確認する必要があります
トークンコントラクトを処理することを想定しており、任意のアドレスを許可しません.

`sender`は、モバイルトークンをリクエストした元のアカウントです
また、 `msg`は` Binary`データであり、コントラクト固有のデータにデコードできます
情報.デフォルトのアクションが1つしかない場合、これは空にすることができます.
または、意図を明確にするための `ReceiveMsg`の変形である可能性があります.例えば、
ユニスワップ契約に送ると、交換したいトークンを指定できます
このフィールドの使用に反対します.

## 手当

契約により、参加者は自分の残高の一部を他の人に委任することができます
アカウント.これはERC20ほど重要ではありません.これは、 `Send`/` Receive`を使用するためです.
`Approve`/` TransferFrom`の代わりにトークンをコントラクトに送信します.しかしそれは
それでも良いユースケースですが、CosmosSDKがどのように追加するかを見ることができます
ネイティブトークンの支払い手当.これは主に提供することです
他の公開鍵ベースのアカウントにアクセスします.

元のERC20承認仕様には競合状態の問題があります.
あなたが50の承認を得て、それを20に減らしたい場合は、コピーを提出します
Txは許容値を20に設定します.表示してすぐに送信する場合tx
50個すべてを使用すると、他の20個にアクセスできます.
私がそれを減らすことができる前に50を使うと、あなたは無料で20を手に入れます.

イーサリアムコミュニティで議論されている解決策は「IncreaseAllowance」です
そして、 `DecreaseAllowance`演算子(` Approve`の代わりに).当初設定
`IncreaseAllowance`を使用して承認されたものは、以前の許可がなくても正常に機能します.
`DecreaseAllowance`は堅牢です.つまり、
現在の許容値(たとえば、ユーザーが途中で費やしたもの)は、四捨五入されます
0に低下し、アンダーフローエラーは生成されません.

### 情報

`IncreaseAllowance {spender、amount、expires}`-許容値を設定または増加します
このようにして、 `spender`は最大` amount + current_allowance`トークンにアクセスできます
`env.sender`アカウントから.これはオプションで「期限切れ」にすることができます
時間(設定されている場合)は、承認された制限(時間または高度による)を使用できます.

`DecreaseAllowance {spender、amount、expires}`-許容量を減らすかクリアする
このようにして、 `spender`は最大` current_allowance-amount`トークンにアクセスできます
`env.sender`アカウントから.これはオプションで「期限切れ」にすることができます
時間(設定されている場合)は、承認された制限(時間または高度による)を使用できます.
`amount> = current_allowance`の場合、これによりクォータがクリアされます(削除されます).

`TransferFrom {owner、receiver、amount}`-これは手当を使用します
`env.sender`に有効な、有効期限が切れていない事前承認がある場合、
次に、 `amount`トークンを` owner`から `recipient`に移動し、それを差し引きます
利用可能な手当から.

`SendFrom {owner、contract、amount、msg}` -`SendFrom`から `Send`、何
`TransferFrom`は` Transfer`になります.これにより、事前に承認されたアカウントが可能になります
トークンを転送するだけでなく、別の契約に送信します
指定されたアクションをトリガーします. **注** `SendFrom`は` Receive {sender} `を設定します
`env.sender`(転送をトリガーするアカウント)になります
「所有者」アカウント(資金が由来するアカウント)ではなく.
これは未解決の質問ですが、切り替える必要がありますか？

`BurnFrom {owner、amount}`-これは `TransferFrom`に似ていますが、書き込みます
トークンを転送する代わりに.これにより、所有者の
残高、 `total_supply`および発信者の手当.

### お問い合わせ

`Allowance {owner、spender}`-これは利用可能な手当を返します
`spender`は` owner`のアカウントからアクセスできます.
有効期限情報.戻りタイプは「AllowanceResponse {balance、expire}」です.

## ミンテーブル

これにより、別のコントラクトが、おそらく上限を使用して、新しいトークンを作成できるようになります.
もっと複雑にしたい場合は、ここで指定されているミントは1つだけです.
アクセス管理、マルチ署名または他の契約を使用してください
ミンターアドレスを指定し、そこで更新ACLを処理します.

### 情報

`Mint {recipient、amount}` -`env.sender`が許可されたミントである場合、
これにより、新しい `amount`トークンが作成され(総供給量が更新されます)、
それらを「受信者」の残高に追加します.

### お問い合わせ

`Minter {}`-ミントできる人とミントできる数を返します.戻りタイプは
`MinterResponse {minter、cap}`.上限が設定されていない場合があります.
